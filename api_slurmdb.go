/*
Slurm Rest API

API to access and control Slurm.

API version: 0.0.40
Contact: sales@schedmd.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package slurmrestapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// SlurmdbAPIService SlurmdbAPI service
type SlurmdbAPIService service

type ApiSlurmdbV0040DeleteAccountRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	accountName string
}

func (r ApiSlurmdbV0040DeleteAccountRequest) Execute() (*V0040OpenapiAccountsRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040DeleteAccountExecute(r)
}

/*
SlurmdbV0040DeleteAccount Delete account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountName Account name
 @return ApiSlurmdbV0040DeleteAccountRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040DeleteAccount(ctx context.Context, accountName string) ApiSlurmdbV0040DeleteAccountRequest {
	return ApiSlurmdbV0040DeleteAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountName: accountName,
	}
}

// Execute executes the request
//  @return V0040OpenapiAccountsRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0040DeleteAccountExecute(r ApiSlurmdbV0040DeleteAccountRequest) (*V0040OpenapiAccountsRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiAccountsRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040DeleteAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/account/{account_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"account_name"+"}", url.PathEscape(parameterValueToString(r.accountName, "accountName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040DeleteAssociationRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	account *string
	cluster *string
	defaultQos *string
	format *string
	id *string
	onlyDefaults *string
	parentAccount *string
	partition *string
	qos *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
	withRawQos *string
	withSubAccts *string
	withoutParentInfo *string
	withoutParentLimits *string
}

// CSV accounts list
func (r ApiSlurmdbV0040DeleteAssociationRequest) Account(account string) ApiSlurmdbV0040DeleteAssociationRequest {
	r.account = &account
	return r
}

// CSV clusters list
func (r ApiSlurmdbV0040DeleteAssociationRequest) Cluster(cluster string) ApiSlurmdbV0040DeleteAssociationRequest {
	r.cluster = &cluster
	return r
}

// CSV QOS list
func (r ApiSlurmdbV0040DeleteAssociationRequest) DefaultQos(defaultQos string) ApiSlurmdbV0040DeleteAssociationRequest {
	r.defaultQos = &defaultQos
	return r
}

// CSV format list
func (r ApiSlurmdbV0040DeleteAssociationRequest) Format(format string) ApiSlurmdbV0040DeleteAssociationRequest {
	r.format = &format
	return r
}

// CSV id list
func (r ApiSlurmdbV0040DeleteAssociationRequest) Id(id string) ApiSlurmdbV0040DeleteAssociationRequest {
	r.id = &id
	return r
}

// filter to only defaults
func (r ApiSlurmdbV0040DeleteAssociationRequest) OnlyDefaults(onlyDefaults string) ApiSlurmdbV0040DeleteAssociationRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// CSV names of parent account
func (r ApiSlurmdbV0040DeleteAssociationRequest) ParentAccount(parentAccount string) ApiSlurmdbV0040DeleteAssociationRequest {
	r.parentAccount = &parentAccount
	return r
}

// CSV partition name list
func (r ApiSlurmdbV0040DeleteAssociationRequest) Partition(partition string) ApiSlurmdbV0040DeleteAssociationRequest {
	r.partition = &partition
	return r
}

// CSV QOS list
func (r ApiSlurmdbV0040DeleteAssociationRequest) Qos(qos string) ApiSlurmdbV0040DeleteAssociationRequest {
	r.qos = &qos
	return r
}

// usage end UNIX timestamp
func (r ApiSlurmdbV0040DeleteAssociationRequest) UsageEnd(usageEnd string) ApiSlurmdbV0040DeleteAssociationRequest {
	r.usageEnd = &usageEnd
	return r
}

// usage start UNIX timestamp
func (r ApiSlurmdbV0040DeleteAssociationRequest) UsageStart(usageStart string) ApiSlurmdbV0040DeleteAssociationRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r ApiSlurmdbV0040DeleteAssociationRequest) User(user string) ApiSlurmdbV0040DeleteAssociationRequest {
	r.user = &user
	return r
}

// fill in usage
func (r ApiSlurmdbV0040DeleteAssociationRequest) WithUsage(withUsage string) ApiSlurmdbV0040DeleteAssociationRequest {
	r.withUsage = &withUsage
	return r
}

// return deleted associations
func (r ApiSlurmdbV0040DeleteAssociationRequest) WithDeleted(withDeleted string) ApiSlurmdbV0040DeleteAssociationRequest {
	r.withDeleted = &withDeleted
	return r
}

// return a raw qos or delta_qos
func (r ApiSlurmdbV0040DeleteAssociationRequest) WithRawQos(withRawQos string) ApiSlurmdbV0040DeleteAssociationRequest {
	r.withRawQos = &withRawQos
	return r
}

// return sub acct information also
func (r ApiSlurmdbV0040DeleteAssociationRequest) WithSubAccts(withSubAccts string) ApiSlurmdbV0040DeleteAssociationRequest {
	r.withSubAccts = &withSubAccts
	return r
}

// don&#39;t give me parent id/name
func (r ApiSlurmdbV0040DeleteAssociationRequest) WithoutParentInfo(withoutParentInfo string) ApiSlurmdbV0040DeleteAssociationRequest {
	r.withoutParentInfo = &withoutParentInfo
	return r
}

// don&#39;t give me limits from parents
func (r ApiSlurmdbV0040DeleteAssociationRequest) WithoutParentLimits(withoutParentLimits string) ApiSlurmdbV0040DeleteAssociationRequest {
	r.withoutParentLimits = &withoutParentLimits
	return r
}

func (r ApiSlurmdbV0040DeleteAssociationRequest) Execute() (*V0040OpenapiAssocsRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040DeleteAssociationExecute(r)
}

/*
SlurmdbV0040DeleteAssociation Delete association

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040DeleteAssociationRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040DeleteAssociation(ctx context.Context) ApiSlurmdbV0040DeleteAssociationRequest {
	return ApiSlurmdbV0040DeleteAssociationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiAssocsRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0040DeleteAssociationExecute(r ApiSlurmdbV0040DeleteAssociationRequest) (*V0040OpenapiAssocsRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiAssocsRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040DeleteAssociation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/association"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.account != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account", r.account, "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "")
	}
	if r.defaultQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_qos", r.defaultQos, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "")
	}
	if r.parentAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_account", r.parentAccount, "")
	}
	if r.partition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partition", r.partition, "")
	}
	if r.qos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qos", r.qos, "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	if r.withRawQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_raw_qos", r.withRawQos, "")
	}
	if r.withSubAccts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_sub_accts", r.withSubAccts, "")
	}
	if r.withoutParentInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_info", r.withoutParentInfo, "")
	}
	if r.withoutParentLimits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_limits", r.withoutParentLimits, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040DeleteAssociationsRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	account *string
	cluster *string
	defaultQos *string
	format *string
	id *string
	onlyDefaults *string
	parentAccount *string
	partition *string
	qos *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
	withRawQos *string
	withSubAccts *string
	withoutParentInfo *string
	withoutParentLimits *string
}

// CSV accounts list
func (r ApiSlurmdbV0040DeleteAssociationsRequest) Account(account string) ApiSlurmdbV0040DeleteAssociationsRequest {
	r.account = &account
	return r
}

// CSV clusters list
func (r ApiSlurmdbV0040DeleteAssociationsRequest) Cluster(cluster string) ApiSlurmdbV0040DeleteAssociationsRequest {
	r.cluster = &cluster
	return r
}

// CSV QOS list
func (r ApiSlurmdbV0040DeleteAssociationsRequest) DefaultQos(defaultQos string) ApiSlurmdbV0040DeleteAssociationsRequest {
	r.defaultQos = &defaultQos
	return r
}

// CSV format list
func (r ApiSlurmdbV0040DeleteAssociationsRequest) Format(format string) ApiSlurmdbV0040DeleteAssociationsRequest {
	r.format = &format
	return r
}

// CSV id list
func (r ApiSlurmdbV0040DeleteAssociationsRequest) Id(id string) ApiSlurmdbV0040DeleteAssociationsRequest {
	r.id = &id
	return r
}

// filter to only defaults
func (r ApiSlurmdbV0040DeleteAssociationsRequest) OnlyDefaults(onlyDefaults string) ApiSlurmdbV0040DeleteAssociationsRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// CSV names of parent account
func (r ApiSlurmdbV0040DeleteAssociationsRequest) ParentAccount(parentAccount string) ApiSlurmdbV0040DeleteAssociationsRequest {
	r.parentAccount = &parentAccount
	return r
}

// CSV partition name list
func (r ApiSlurmdbV0040DeleteAssociationsRequest) Partition(partition string) ApiSlurmdbV0040DeleteAssociationsRequest {
	r.partition = &partition
	return r
}

// CSV QOS list
func (r ApiSlurmdbV0040DeleteAssociationsRequest) Qos(qos string) ApiSlurmdbV0040DeleteAssociationsRequest {
	r.qos = &qos
	return r
}

// usage end UNIX timestamp
func (r ApiSlurmdbV0040DeleteAssociationsRequest) UsageEnd(usageEnd string) ApiSlurmdbV0040DeleteAssociationsRequest {
	r.usageEnd = &usageEnd
	return r
}

// usage start UNIX timestamp
func (r ApiSlurmdbV0040DeleteAssociationsRequest) UsageStart(usageStart string) ApiSlurmdbV0040DeleteAssociationsRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r ApiSlurmdbV0040DeleteAssociationsRequest) User(user string) ApiSlurmdbV0040DeleteAssociationsRequest {
	r.user = &user
	return r
}

// fill in usage
func (r ApiSlurmdbV0040DeleteAssociationsRequest) WithUsage(withUsage string) ApiSlurmdbV0040DeleteAssociationsRequest {
	r.withUsage = &withUsage
	return r
}

// return deleted associations
func (r ApiSlurmdbV0040DeleteAssociationsRequest) WithDeleted(withDeleted string) ApiSlurmdbV0040DeleteAssociationsRequest {
	r.withDeleted = &withDeleted
	return r
}

// return a raw qos or delta_qos
func (r ApiSlurmdbV0040DeleteAssociationsRequest) WithRawQos(withRawQos string) ApiSlurmdbV0040DeleteAssociationsRequest {
	r.withRawQos = &withRawQos
	return r
}

// return sub acct information also
func (r ApiSlurmdbV0040DeleteAssociationsRequest) WithSubAccts(withSubAccts string) ApiSlurmdbV0040DeleteAssociationsRequest {
	r.withSubAccts = &withSubAccts
	return r
}

// don&#39;t give me parent id/name
func (r ApiSlurmdbV0040DeleteAssociationsRequest) WithoutParentInfo(withoutParentInfo string) ApiSlurmdbV0040DeleteAssociationsRequest {
	r.withoutParentInfo = &withoutParentInfo
	return r
}

// don&#39;t give me limits from parents
func (r ApiSlurmdbV0040DeleteAssociationsRequest) WithoutParentLimits(withoutParentLimits string) ApiSlurmdbV0040DeleteAssociationsRequest {
	r.withoutParentLimits = &withoutParentLimits
	return r
}

func (r ApiSlurmdbV0040DeleteAssociationsRequest) Execute() (*V0040OpenapiAssocsRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040DeleteAssociationsExecute(r)
}

/*
SlurmdbV0040DeleteAssociations Delete associations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040DeleteAssociationsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040DeleteAssociations(ctx context.Context) ApiSlurmdbV0040DeleteAssociationsRequest {
	return ApiSlurmdbV0040DeleteAssociationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiAssocsRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0040DeleteAssociationsExecute(r ApiSlurmdbV0040DeleteAssociationsRequest) (*V0040OpenapiAssocsRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiAssocsRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040DeleteAssociations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/associations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.account != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account", r.account, "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "")
	}
	if r.defaultQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_qos", r.defaultQos, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "")
	}
	if r.parentAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_account", r.parentAccount, "")
	}
	if r.partition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partition", r.partition, "")
	}
	if r.qos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qos", r.qos, "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	if r.withRawQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_raw_qos", r.withRawQos, "")
	}
	if r.withSubAccts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_sub_accts", r.withSubAccts, "")
	}
	if r.withoutParentInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_info", r.withoutParentInfo, "")
	}
	if r.withoutParentLimits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_limits", r.withoutParentLimits, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040DeleteClusterRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	clusterName string
	classification *string
	cluster *string
	federation *string
	flags *string
	format *string
	rpcVersion *string
	usageEnd *string
	usageStart *string
	withDeleted *string
	withUsage *string
}

func (r ApiSlurmdbV0040DeleteClusterRequest) Classification(classification string) ApiSlurmdbV0040DeleteClusterRequest {
	r.classification = &classification
	return r
}

// CSV cluster list
func (r ApiSlurmdbV0040DeleteClusterRequest) Cluster(cluster string) ApiSlurmdbV0040DeleteClusterRequest {
	r.cluster = &cluster
	return r
}

// CSV federation list
func (r ApiSlurmdbV0040DeleteClusterRequest) Federation(federation string) ApiSlurmdbV0040DeleteClusterRequest {
	r.federation = &federation
	return r
}

func (r ApiSlurmdbV0040DeleteClusterRequest) Flags(flags string) ApiSlurmdbV0040DeleteClusterRequest {
	r.flags = &flags
	return r
}

// CSV format list
func (r ApiSlurmdbV0040DeleteClusterRequest) Format(format string) ApiSlurmdbV0040DeleteClusterRequest {
	r.format = &format
	return r
}

// CSV RPC version list
func (r ApiSlurmdbV0040DeleteClusterRequest) RpcVersion(rpcVersion string) ApiSlurmdbV0040DeleteClusterRequest {
	r.rpcVersion = &rpcVersion
	return r
}

// Usage end UNIX timestamp (seconds)
func (r ApiSlurmdbV0040DeleteClusterRequest) UsageEnd(usageEnd string) ApiSlurmdbV0040DeleteClusterRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start UNIX timestamp (seconds)
func (r ApiSlurmdbV0040DeleteClusterRequest) UsageStart(usageStart string) ApiSlurmdbV0040DeleteClusterRequest {
	r.usageStart = &usageStart
	return r
}

// include deleted clusters
func (r ApiSlurmdbV0040DeleteClusterRequest) WithDeleted(withDeleted string) ApiSlurmdbV0040DeleteClusterRequest {
	r.withDeleted = &withDeleted
	return r
}

// query usage
func (r ApiSlurmdbV0040DeleteClusterRequest) WithUsage(withUsage string) ApiSlurmdbV0040DeleteClusterRequest {
	r.withUsage = &withUsage
	return r
}

func (r ApiSlurmdbV0040DeleteClusterRequest) Execute() (*V0040OpenapiClustersRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040DeleteClusterExecute(r)
}

/*
SlurmdbV0040DeleteCluster Delete cluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterName Cluster name
 @return ApiSlurmdbV0040DeleteClusterRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040DeleteCluster(ctx context.Context, clusterName string) ApiSlurmdbV0040DeleteClusterRequest {
	return ApiSlurmdbV0040DeleteClusterRequest{
		ApiService: a,
		ctx: ctx,
		clusterName: clusterName,
	}
}

// Execute executes the request
//  @return V0040OpenapiClustersRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0040DeleteClusterExecute(r ApiSlurmdbV0040DeleteClusterRequest) (*V0040OpenapiClustersRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiClustersRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040DeleteCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/cluster/{cluster_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_name"+"}", url.PathEscape(parameterValueToString(r.clusterName, "clusterName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.classification != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "classification", r.classification, "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "")
	}
	if r.federation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "federation", r.federation, "")
	}
	if r.flags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flags", r.flags, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.rpcVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rpc_version", r.rpcVersion, "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040DeleteSingleQosRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	qos string
}

func (r ApiSlurmdbV0040DeleteSingleQosRequest) Execute() (*V0040OpenapiSlurmdbdQosRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040DeleteSingleQosExecute(r)
}

/*
SlurmdbV0040DeleteSingleQos Delete QOS

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param qos QOS name
 @return ApiSlurmdbV0040DeleteSingleQosRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040DeleteSingleQos(ctx context.Context, qos string) ApiSlurmdbV0040DeleteSingleQosRequest {
	return ApiSlurmdbV0040DeleteSingleQosRequest{
		ApiService: a,
		ctx: ctx,
		qos: qos,
	}
}

// Execute executes the request
//  @return V0040OpenapiSlurmdbdQosRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0040DeleteSingleQosExecute(r ApiSlurmdbV0040DeleteSingleQosRequest) (*V0040OpenapiSlurmdbdQosRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiSlurmdbdQosRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040DeleteSingleQos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/qos/{qos}"
	localVarPath = strings.Replace(localVarPath, "{"+"qos"+"}", url.PathEscape(parameterValueToString(r.qos, "qos")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040DeleteUserRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	name string
}

func (r ApiSlurmdbV0040DeleteUserRequest) Execute() (*V0040OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040DeleteUserExecute(r)
}

/*
SlurmdbV0040DeleteUser Delete user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name User name
 @return ApiSlurmdbV0040DeleteUserRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040DeleteUser(ctx context.Context, name string) ApiSlurmdbV0040DeleteUserRequest {
	return ApiSlurmdbV0040DeleteUserRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V0040OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0040DeleteUserExecute(r ApiSlurmdbV0040DeleteUserRequest) (*V0040OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040DeleteUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/user/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040DeleteWckeyRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	id string
}

func (r ApiSlurmdbV0040DeleteWckeyRequest) Execute() (*V0040OpenapiWckeyRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040DeleteWckeyExecute(r)
}

/*
SlurmdbV0040DeleteWckey Delete wckey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id wckey id
 @return ApiSlurmdbV0040DeleteWckeyRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040DeleteWckey(ctx context.Context, id string) ApiSlurmdbV0040DeleteWckeyRequest {
	return ApiSlurmdbV0040DeleteWckeyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V0040OpenapiWckeyRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0040DeleteWckeyExecute(r ApiSlurmdbV0040DeleteWckeyRequest) (*V0040OpenapiWckeyRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiWckeyRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040DeleteWckey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/wckey/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetAccountRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	accountName string
	withAssocs *string
	withCoords *string
	withDeleted *string
}

// include associations
func (r ApiSlurmdbV0040GetAccountRequest) WithAssocs(withAssocs string) ApiSlurmdbV0040GetAccountRequest {
	r.withAssocs = &withAssocs
	return r
}

// include coordinators
func (r ApiSlurmdbV0040GetAccountRequest) WithCoords(withCoords string) ApiSlurmdbV0040GetAccountRequest {
	r.withCoords = &withCoords
	return r
}

// include deleted
func (r ApiSlurmdbV0040GetAccountRequest) WithDeleted(withDeleted string) ApiSlurmdbV0040GetAccountRequest {
	r.withDeleted = &withDeleted
	return r
}

func (r ApiSlurmdbV0040GetAccountRequest) Execute() (*V0040OpenapiAccountsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetAccountExecute(r)
}

/*
SlurmdbV0040GetAccount Get account info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountName Account name
 @return ApiSlurmdbV0040GetAccountRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetAccount(ctx context.Context, accountName string) ApiSlurmdbV0040GetAccountRequest {
	return ApiSlurmdbV0040GetAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountName: accountName,
	}
}

// Execute executes the request
//  @return V0040OpenapiAccountsResp
func (a *SlurmdbAPIService) SlurmdbV0040GetAccountExecute(r ApiSlurmdbV0040GetAccountRequest) (*V0040OpenapiAccountsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiAccountsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/account/{account_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"account_name"+"}", url.PathEscape(parameterValueToString(r.accountName, "accountName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.withAssocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_assocs", r.withAssocs, "")
	}
	if r.withCoords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_coords", r.withCoords, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetAccountsRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	description *string
	withAssocs *string
	withCoords *string
	withDeleted *string
}

// CSV description list
func (r ApiSlurmdbV0040GetAccountsRequest) Description(description string) ApiSlurmdbV0040GetAccountsRequest {
	r.description = &description
	return r
}

// include associations
func (r ApiSlurmdbV0040GetAccountsRequest) WithAssocs(withAssocs string) ApiSlurmdbV0040GetAccountsRequest {
	r.withAssocs = &withAssocs
	return r
}

// include coordinators
func (r ApiSlurmdbV0040GetAccountsRequest) WithCoords(withCoords string) ApiSlurmdbV0040GetAccountsRequest {
	r.withCoords = &withCoords
	return r
}

// include deleted accounts
func (r ApiSlurmdbV0040GetAccountsRequest) WithDeleted(withDeleted string) ApiSlurmdbV0040GetAccountsRequest {
	r.withDeleted = &withDeleted
	return r
}

func (r ApiSlurmdbV0040GetAccountsRequest) Execute() (*V0040OpenapiAccountsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetAccountsExecute(r)
}

/*
SlurmdbV0040GetAccounts Get account list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040GetAccountsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetAccounts(ctx context.Context) ApiSlurmdbV0040GetAccountsRequest {
	return ApiSlurmdbV0040GetAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiAccountsResp
func (a *SlurmdbAPIService) SlurmdbV0040GetAccountsExecute(r ApiSlurmdbV0040GetAccountsRequest) (*V0040OpenapiAccountsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiAccountsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	if r.withAssocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_assocs", r.withAssocs, "")
	}
	if r.withCoords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_coords", r.withCoords, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetAssociationRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	account *string
	cluster *string
	defaultQos *string
	format *string
	id *string
	onlyDefaults *string
	parentAccount *string
	partition *string
	qos *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
	withRawQos *string
	withSubAccts *string
	withoutParentInfo *string
	withoutParentLimits *string
}

// CSV accounts list
func (r ApiSlurmdbV0040GetAssociationRequest) Account(account string) ApiSlurmdbV0040GetAssociationRequest {
	r.account = &account
	return r
}

// CSV clusters list
func (r ApiSlurmdbV0040GetAssociationRequest) Cluster(cluster string) ApiSlurmdbV0040GetAssociationRequest {
	r.cluster = &cluster
	return r
}

// CSV QOS list
func (r ApiSlurmdbV0040GetAssociationRequest) DefaultQos(defaultQos string) ApiSlurmdbV0040GetAssociationRequest {
	r.defaultQos = &defaultQos
	return r
}

// CSV format list
func (r ApiSlurmdbV0040GetAssociationRequest) Format(format string) ApiSlurmdbV0040GetAssociationRequest {
	r.format = &format
	return r
}

// CSV id list
func (r ApiSlurmdbV0040GetAssociationRequest) Id(id string) ApiSlurmdbV0040GetAssociationRequest {
	r.id = &id
	return r
}

// filter to only defaults
func (r ApiSlurmdbV0040GetAssociationRequest) OnlyDefaults(onlyDefaults string) ApiSlurmdbV0040GetAssociationRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// CSV names of parent account
func (r ApiSlurmdbV0040GetAssociationRequest) ParentAccount(parentAccount string) ApiSlurmdbV0040GetAssociationRequest {
	r.parentAccount = &parentAccount
	return r
}

// CSV partition name list
func (r ApiSlurmdbV0040GetAssociationRequest) Partition(partition string) ApiSlurmdbV0040GetAssociationRequest {
	r.partition = &partition
	return r
}

// CSV QOS list
func (r ApiSlurmdbV0040GetAssociationRequest) Qos(qos string) ApiSlurmdbV0040GetAssociationRequest {
	r.qos = &qos
	return r
}

// usage end UNIX timestamp
func (r ApiSlurmdbV0040GetAssociationRequest) UsageEnd(usageEnd string) ApiSlurmdbV0040GetAssociationRequest {
	r.usageEnd = &usageEnd
	return r
}

// usage start UNIX timestamp
func (r ApiSlurmdbV0040GetAssociationRequest) UsageStart(usageStart string) ApiSlurmdbV0040GetAssociationRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r ApiSlurmdbV0040GetAssociationRequest) User(user string) ApiSlurmdbV0040GetAssociationRequest {
	r.user = &user
	return r
}

// fill in usage
func (r ApiSlurmdbV0040GetAssociationRequest) WithUsage(withUsage string) ApiSlurmdbV0040GetAssociationRequest {
	r.withUsage = &withUsage
	return r
}

// return deleted associations
func (r ApiSlurmdbV0040GetAssociationRequest) WithDeleted(withDeleted string) ApiSlurmdbV0040GetAssociationRequest {
	r.withDeleted = &withDeleted
	return r
}

// return a raw qos or delta_qos
func (r ApiSlurmdbV0040GetAssociationRequest) WithRawQos(withRawQos string) ApiSlurmdbV0040GetAssociationRequest {
	r.withRawQos = &withRawQos
	return r
}

// return sub acct information also
func (r ApiSlurmdbV0040GetAssociationRequest) WithSubAccts(withSubAccts string) ApiSlurmdbV0040GetAssociationRequest {
	r.withSubAccts = &withSubAccts
	return r
}

// don&#39;t give me parent id/name
func (r ApiSlurmdbV0040GetAssociationRequest) WithoutParentInfo(withoutParentInfo string) ApiSlurmdbV0040GetAssociationRequest {
	r.withoutParentInfo = &withoutParentInfo
	return r
}

// don&#39;t give me limits from parents
func (r ApiSlurmdbV0040GetAssociationRequest) WithoutParentLimits(withoutParentLimits string) ApiSlurmdbV0040GetAssociationRequest {
	r.withoutParentLimits = &withoutParentLimits
	return r
}

func (r ApiSlurmdbV0040GetAssociationRequest) Execute() (*V0040OpenapiAssocsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetAssociationExecute(r)
}

/*
SlurmdbV0040GetAssociation Get association info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040GetAssociationRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetAssociation(ctx context.Context) ApiSlurmdbV0040GetAssociationRequest {
	return ApiSlurmdbV0040GetAssociationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiAssocsResp
func (a *SlurmdbAPIService) SlurmdbV0040GetAssociationExecute(r ApiSlurmdbV0040GetAssociationRequest) (*V0040OpenapiAssocsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiAssocsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetAssociation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/association"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.account != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account", r.account, "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "")
	}
	if r.defaultQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_qos", r.defaultQos, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "")
	}
	if r.parentAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_account", r.parentAccount, "")
	}
	if r.partition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partition", r.partition, "")
	}
	if r.qos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qos", r.qos, "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	if r.withRawQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_raw_qos", r.withRawQos, "")
	}
	if r.withSubAccts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_sub_accts", r.withSubAccts, "")
	}
	if r.withoutParentInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_info", r.withoutParentInfo, "")
	}
	if r.withoutParentLimits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_limits", r.withoutParentLimits, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiAssocsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetAssociationsRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	account *string
	cluster *string
	defaultQos *string
	format *string
	id *string
	onlyDefaults *string
	parentAccount *string
	partition *string
	qos *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
	withRawQos *string
	withSubAccts *string
	withoutParentInfo *string
	withoutParentLimits *string
}

// CSV accounts list
func (r ApiSlurmdbV0040GetAssociationsRequest) Account(account string) ApiSlurmdbV0040GetAssociationsRequest {
	r.account = &account
	return r
}

// CSV clusters list
func (r ApiSlurmdbV0040GetAssociationsRequest) Cluster(cluster string) ApiSlurmdbV0040GetAssociationsRequest {
	r.cluster = &cluster
	return r
}

// CSV QOS list
func (r ApiSlurmdbV0040GetAssociationsRequest) DefaultQos(defaultQos string) ApiSlurmdbV0040GetAssociationsRequest {
	r.defaultQos = &defaultQos
	return r
}

// CSV format list
func (r ApiSlurmdbV0040GetAssociationsRequest) Format(format string) ApiSlurmdbV0040GetAssociationsRequest {
	r.format = &format
	return r
}

// CSV id list
func (r ApiSlurmdbV0040GetAssociationsRequest) Id(id string) ApiSlurmdbV0040GetAssociationsRequest {
	r.id = &id
	return r
}

// filter to only defaults
func (r ApiSlurmdbV0040GetAssociationsRequest) OnlyDefaults(onlyDefaults string) ApiSlurmdbV0040GetAssociationsRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// CSV names of parent account
func (r ApiSlurmdbV0040GetAssociationsRequest) ParentAccount(parentAccount string) ApiSlurmdbV0040GetAssociationsRequest {
	r.parentAccount = &parentAccount
	return r
}

// CSV partition name list
func (r ApiSlurmdbV0040GetAssociationsRequest) Partition(partition string) ApiSlurmdbV0040GetAssociationsRequest {
	r.partition = &partition
	return r
}

// CSV QOS list
func (r ApiSlurmdbV0040GetAssociationsRequest) Qos(qos string) ApiSlurmdbV0040GetAssociationsRequest {
	r.qos = &qos
	return r
}

// usage end UNIX timestamp
func (r ApiSlurmdbV0040GetAssociationsRequest) UsageEnd(usageEnd string) ApiSlurmdbV0040GetAssociationsRequest {
	r.usageEnd = &usageEnd
	return r
}

// usage start UNIX timestamp
func (r ApiSlurmdbV0040GetAssociationsRequest) UsageStart(usageStart string) ApiSlurmdbV0040GetAssociationsRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r ApiSlurmdbV0040GetAssociationsRequest) User(user string) ApiSlurmdbV0040GetAssociationsRequest {
	r.user = &user
	return r
}

// fill in usage
func (r ApiSlurmdbV0040GetAssociationsRequest) WithUsage(withUsage string) ApiSlurmdbV0040GetAssociationsRequest {
	r.withUsage = &withUsage
	return r
}

// return deleted associations
func (r ApiSlurmdbV0040GetAssociationsRequest) WithDeleted(withDeleted string) ApiSlurmdbV0040GetAssociationsRequest {
	r.withDeleted = &withDeleted
	return r
}

// return a raw qos or delta_qos
func (r ApiSlurmdbV0040GetAssociationsRequest) WithRawQos(withRawQos string) ApiSlurmdbV0040GetAssociationsRequest {
	r.withRawQos = &withRawQos
	return r
}

// return sub acct information also
func (r ApiSlurmdbV0040GetAssociationsRequest) WithSubAccts(withSubAccts string) ApiSlurmdbV0040GetAssociationsRequest {
	r.withSubAccts = &withSubAccts
	return r
}

// don&#39;t give me parent id/name
func (r ApiSlurmdbV0040GetAssociationsRequest) WithoutParentInfo(withoutParentInfo string) ApiSlurmdbV0040GetAssociationsRequest {
	r.withoutParentInfo = &withoutParentInfo
	return r
}

// don&#39;t give me limits from parents
func (r ApiSlurmdbV0040GetAssociationsRequest) WithoutParentLimits(withoutParentLimits string) ApiSlurmdbV0040GetAssociationsRequest {
	r.withoutParentLimits = &withoutParentLimits
	return r
}

func (r ApiSlurmdbV0040GetAssociationsRequest) Execute() (*V0040OpenapiAssocsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetAssociationsExecute(r)
}

/*
SlurmdbV0040GetAssociations Get association list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040GetAssociationsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetAssociations(ctx context.Context) ApiSlurmdbV0040GetAssociationsRequest {
	return ApiSlurmdbV0040GetAssociationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiAssocsResp
func (a *SlurmdbAPIService) SlurmdbV0040GetAssociationsExecute(r ApiSlurmdbV0040GetAssociationsRequest) (*V0040OpenapiAssocsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiAssocsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetAssociations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/associations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.account != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account", r.account, "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "")
	}
	if r.defaultQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_qos", r.defaultQos, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "")
	}
	if r.parentAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_account", r.parentAccount, "")
	}
	if r.partition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partition", r.partition, "")
	}
	if r.qos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qos", r.qos, "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	if r.withRawQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_raw_qos", r.withRawQos, "")
	}
	if r.withSubAccts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_sub_accts", r.withSubAccts, "")
	}
	if r.withoutParentInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_info", r.withoutParentInfo, "")
	}
	if r.withoutParentLimits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_limits", r.withoutParentLimits, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetClusterRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	clusterName string
	classification *string
	cluster *string
	federation *string
	flags *string
	format *string
	rpcVersion *string
	usageEnd *string
	usageStart *string
	withDeleted *string
	withUsage *string
}

func (r ApiSlurmdbV0040GetClusterRequest) Classification(classification string) ApiSlurmdbV0040GetClusterRequest {
	r.classification = &classification
	return r
}

// CSV cluster list
func (r ApiSlurmdbV0040GetClusterRequest) Cluster(cluster string) ApiSlurmdbV0040GetClusterRequest {
	r.cluster = &cluster
	return r
}

// CSV federation list
func (r ApiSlurmdbV0040GetClusterRequest) Federation(federation string) ApiSlurmdbV0040GetClusterRequest {
	r.federation = &federation
	return r
}

func (r ApiSlurmdbV0040GetClusterRequest) Flags(flags string) ApiSlurmdbV0040GetClusterRequest {
	r.flags = &flags
	return r
}

// CSV format list
func (r ApiSlurmdbV0040GetClusterRequest) Format(format string) ApiSlurmdbV0040GetClusterRequest {
	r.format = &format
	return r
}

// CSV RPC version list
func (r ApiSlurmdbV0040GetClusterRequest) RpcVersion(rpcVersion string) ApiSlurmdbV0040GetClusterRequest {
	r.rpcVersion = &rpcVersion
	return r
}

// Usage end UNIX timestamp (seconds)
func (r ApiSlurmdbV0040GetClusterRequest) UsageEnd(usageEnd string) ApiSlurmdbV0040GetClusterRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start UNIX timestamp (seconds)
func (r ApiSlurmdbV0040GetClusterRequest) UsageStart(usageStart string) ApiSlurmdbV0040GetClusterRequest {
	r.usageStart = &usageStart
	return r
}

// include deleted clusters
func (r ApiSlurmdbV0040GetClusterRequest) WithDeleted(withDeleted string) ApiSlurmdbV0040GetClusterRequest {
	r.withDeleted = &withDeleted
	return r
}

// query usage
func (r ApiSlurmdbV0040GetClusterRequest) WithUsage(withUsage string) ApiSlurmdbV0040GetClusterRequest {
	r.withUsage = &withUsage
	return r
}

func (r ApiSlurmdbV0040GetClusterRequest) Execute() (*V0040OpenapiClustersResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetClusterExecute(r)
}

/*
SlurmdbV0040GetCluster Get cluster info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterName Cluster name
 @return ApiSlurmdbV0040GetClusterRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetCluster(ctx context.Context, clusterName string) ApiSlurmdbV0040GetClusterRequest {
	return ApiSlurmdbV0040GetClusterRequest{
		ApiService: a,
		ctx: ctx,
		clusterName: clusterName,
	}
}

// Execute executes the request
//  @return V0040OpenapiClustersResp
func (a *SlurmdbAPIService) SlurmdbV0040GetClusterExecute(r ApiSlurmdbV0040GetClusterRequest) (*V0040OpenapiClustersResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiClustersResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/cluster/{cluster_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_name"+"}", url.PathEscape(parameterValueToString(r.clusterName, "clusterName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.classification != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "classification", r.classification, "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "")
	}
	if r.federation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "federation", r.federation, "")
	}
	if r.flags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flags", r.flags, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.rpcVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rpc_version", r.rpcVersion, "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetClustersRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	classification *string
	cluster *string
	federation *string
	flags *string
	format *string
	rpcVersion *string
	usageEnd *string
	usageStart *string
	withDeleted *string
	withUsage *string
}

func (r ApiSlurmdbV0040GetClustersRequest) Classification(classification string) ApiSlurmdbV0040GetClustersRequest {
	r.classification = &classification
	return r
}

// CSV cluster list
func (r ApiSlurmdbV0040GetClustersRequest) Cluster(cluster string) ApiSlurmdbV0040GetClustersRequest {
	r.cluster = &cluster
	return r
}

// CSV federation list
func (r ApiSlurmdbV0040GetClustersRequest) Federation(federation string) ApiSlurmdbV0040GetClustersRequest {
	r.federation = &federation
	return r
}

func (r ApiSlurmdbV0040GetClustersRequest) Flags(flags string) ApiSlurmdbV0040GetClustersRequest {
	r.flags = &flags
	return r
}

// CSV format list
func (r ApiSlurmdbV0040GetClustersRequest) Format(format string) ApiSlurmdbV0040GetClustersRequest {
	r.format = &format
	return r
}

// CSV RPC version list
func (r ApiSlurmdbV0040GetClustersRequest) RpcVersion(rpcVersion string) ApiSlurmdbV0040GetClustersRequest {
	r.rpcVersion = &rpcVersion
	return r
}

// Usage end UNIX timestamp (seconds)
func (r ApiSlurmdbV0040GetClustersRequest) UsageEnd(usageEnd string) ApiSlurmdbV0040GetClustersRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start UNIX timestamp (seconds)
func (r ApiSlurmdbV0040GetClustersRequest) UsageStart(usageStart string) ApiSlurmdbV0040GetClustersRequest {
	r.usageStart = &usageStart
	return r
}

// include deleted clusters
func (r ApiSlurmdbV0040GetClustersRequest) WithDeleted(withDeleted string) ApiSlurmdbV0040GetClustersRequest {
	r.withDeleted = &withDeleted
	return r
}

// query usage
func (r ApiSlurmdbV0040GetClustersRequest) WithUsage(withUsage string) ApiSlurmdbV0040GetClustersRequest {
	r.withUsage = &withUsage
	return r
}

func (r ApiSlurmdbV0040GetClustersRequest) Execute() (*V0040OpenapiClustersResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetClustersExecute(r)
}

/*
SlurmdbV0040GetClusters Get cluster list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040GetClustersRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetClusters(ctx context.Context) ApiSlurmdbV0040GetClustersRequest {
	return ApiSlurmdbV0040GetClustersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiClustersResp
func (a *SlurmdbAPIService) SlurmdbV0040GetClustersExecute(r ApiSlurmdbV0040GetClustersRequest) (*V0040OpenapiClustersResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiClustersResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetClusters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/clusters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.classification != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "classification", r.classification, "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "")
	}
	if r.federation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "federation", r.federation, "")
	}
	if r.flags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flags", r.flags, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.rpcVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rpc_version", r.rpcVersion, "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetConfigRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
}

func (r ApiSlurmdbV0040GetConfigRequest) Execute() (*V0040OpenapiSlurmdbdConfigResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetConfigExecute(r)
}

/*
SlurmdbV0040GetConfig Dump all configuration information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040GetConfigRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetConfig(ctx context.Context) ApiSlurmdbV0040GetConfigRequest {
	return ApiSlurmdbV0040GetConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiSlurmdbdConfigResp
func (a *SlurmdbAPIService) SlurmdbV0040GetConfigExecute(r ApiSlurmdbV0040GetConfigRequest) (*V0040OpenapiSlurmdbdConfigResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiSlurmdbdConfigResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetDiagRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
}

func (r ApiSlurmdbV0040GetDiagRequest) Execute() (*V0040OpenapiSlurmdbdStatsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetDiagExecute(r)
}

/*
SlurmdbV0040GetDiag Get slurmdb diagnostics

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040GetDiagRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetDiag(ctx context.Context) ApiSlurmdbV0040GetDiagRequest {
	return ApiSlurmdbV0040GetDiagRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiSlurmdbdStatsResp
func (a *SlurmdbAPIService) SlurmdbV0040GetDiagExecute(r ApiSlurmdbV0040GetDiagRequest) (*V0040OpenapiSlurmdbdStatsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiSlurmdbdStatsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetDiag")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/diag"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetInstanceRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	cluster *string
	extra *string
	instanceId *string
	instanceType *string
}

// Cluster name
func (r ApiSlurmdbV0040GetInstanceRequest) Cluster(cluster string) ApiSlurmdbV0040GetInstanceRequest {
	r.cluster = &cluster
	return r
}

// Arbitrary string
func (r ApiSlurmdbV0040GetInstanceRequest) Extra(extra string) ApiSlurmdbV0040GetInstanceRequest {
	r.extra = &extra
	return r
}

// Cloud instance ID
func (r ApiSlurmdbV0040GetInstanceRequest) InstanceId(instanceId string) ApiSlurmdbV0040GetInstanceRequest {
	r.instanceId = &instanceId
	return r
}

// Cloud instance type
func (r ApiSlurmdbV0040GetInstanceRequest) InstanceType(instanceType string) ApiSlurmdbV0040GetInstanceRequest {
	r.instanceType = &instanceType
	return r
}

func (r ApiSlurmdbV0040GetInstanceRequest) Execute() (*V0040OpenapiInstancesResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetInstanceExecute(r)
}

/*
SlurmdbV0040GetInstance Get instance info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040GetInstanceRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetInstance(ctx context.Context) ApiSlurmdbV0040GetInstanceRequest {
	return ApiSlurmdbV0040GetInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiInstancesResp
func (a *SlurmdbAPIService) SlurmdbV0040GetInstanceExecute(r ApiSlurmdbV0040GetInstanceRequest) (*V0040OpenapiInstancesResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiInstancesResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/instance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "")
	}
	if r.extra != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extra", r.extra, "")
	}
	if r.instanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instance_id", r.instanceId, "")
	}
	if r.instanceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instance_type", r.instanceType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetInstancesRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	cluster *string
	extra *string
	instanceId *string
	instanceType *string
}

// Cluster name
func (r ApiSlurmdbV0040GetInstancesRequest) Cluster(cluster string) ApiSlurmdbV0040GetInstancesRequest {
	r.cluster = &cluster
	return r
}

// Arbitrary string
func (r ApiSlurmdbV0040GetInstancesRequest) Extra(extra string) ApiSlurmdbV0040GetInstancesRequest {
	r.extra = &extra
	return r
}

// Cloud instance ID
func (r ApiSlurmdbV0040GetInstancesRequest) InstanceId(instanceId string) ApiSlurmdbV0040GetInstancesRequest {
	r.instanceId = &instanceId
	return r
}

// Cloud instance type
func (r ApiSlurmdbV0040GetInstancesRequest) InstanceType(instanceType string) ApiSlurmdbV0040GetInstancesRequest {
	r.instanceType = &instanceType
	return r
}

func (r ApiSlurmdbV0040GetInstancesRequest) Execute() (*V0040OpenapiInstancesResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetInstancesExecute(r)
}

/*
SlurmdbV0040GetInstances Get instance list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040GetInstancesRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetInstances(ctx context.Context) ApiSlurmdbV0040GetInstancesRequest {
	return ApiSlurmdbV0040GetInstancesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiInstancesResp
func (a *SlurmdbAPIService) SlurmdbV0040GetInstancesExecute(r ApiSlurmdbV0040GetInstancesRequest) (*V0040OpenapiInstancesResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiInstancesResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetInstances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/instances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "")
	}
	if r.extra != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extra", r.extra, "")
	}
	if r.instanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instance_id", r.instanceId, "")
	}
	if r.instanceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instance_type", r.instanceType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetJobRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	jobId string
}

func (r ApiSlurmdbV0040GetJobRequest) Execute() (*V0040OpenapiSlurmdbdJobsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetJobExecute(r)
}

/*
SlurmdbV0040GetJob Get job info

This endpoint may return multiple job entries since job_id is not a unique key - only the tuple (cluster, job_id, start_time) is unique. If the requested job_id is a component of a heterogeneous job all components are returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId Job id
 @return ApiSlurmdbV0040GetJobRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetJob(ctx context.Context, jobId string) ApiSlurmdbV0040GetJobRequest {
	return ApiSlurmdbV0040GetJobRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return V0040OpenapiSlurmdbdJobsResp
func (a *SlurmdbAPIService) SlurmdbV0040GetJobExecute(r ApiSlurmdbV0040GetJobRequest) (*V0040OpenapiSlurmdbdJobsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiSlurmdbdJobsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/job/{job_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetJobsRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	account *string
	association *string
	cluster *string
	constraints *string
	cpusMax *string
	cpusMin *string
	schedulerUnset *string
	scheduledOnSubmit *string
	scheduledByMain *string
	scheduledByBackfill *string
	jobStarted *string
	exitCode *string
	showDuplicates *string
	skipSteps *string
	disableTruncateUsageTime *string
	wholeHetjob *string
	disableWholeHetjob *string
	disableWaitForResult *string
	usageTimeAsSubmitTime *string
	showBatchScript *string
	showJobEnvironment *string
	format *string
	groups *string
	jobName *string
	nodesMax *string
	nodesMin *string
	partition *string
	qos *string
	reason *string
	reservation *string
	reservationId *string
	state *string
	step *string
	timelimitMax *string
	timelimitMin *string
	endTime *string
	startTime *string
	submitTime *string
	node *string
	users *string
	wckey *string
}

// CSV account list
func (r ApiSlurmdbV0040GetJobsRequest) Account(account string) ApiSlurmdbV0040GetJobsRequest {
	r.account = &account
	return r
}

// CSV association list
func (r ApiSlurmdbV0040GetJobsRequest) Association(association string) ApiSlurmdbV0040GetJobsRequest {
	r.association = &association
	return r
}

// CSV cluster list
func (r ApiSlurmdbV0040GetJobsRequest) Cluster(cluster string) ApiSlurmdbV0040GetJobsRequest {
	r.cluster = &cluster
	return r
}

// CSV constraint list
func (r ApiSlurmdbV0040GetJobsRequest) Constraints(constraints string) ApiSlurmdbV0040GetJobsRequest {
	r.constraints = &constraints
	return r
}

// number of cpus high range
func (r ApiSlurmdbV0040GetJobsRequest) CpusMax(cpusMax string) ApiSlurmdbV0040GetJobsRequest {
	r.cpusMax = &cpusMax
	return r
}

// number of cpus low range
func (r ApiSlurmdbV0040GetJobsRequest) CpusMin(cpusMin string) ApiSlurmdbV0040GetJobsRequest {
	r.cpusMin = &cpusMin
	return r
}

func (r ApiSlurmdbV0040GetJobsRequest) SchedulerUnset(schedulerUnset string) ApiSlurmdbV0040GetJobsRequest {
	r.schedulerUnset = &schedulerUnset
	return r
}

func (r ApiSlurmdbV0040GetJobsRequest) ScheduledOnSubmit(scheduledOnSubmit string) ApiSlurmdbV0040GetJobsRequest {
	r.scheduledOnSubmit = &scheduledOnSubmit
	return r
}

func (r ApiSlurmdbV0040GetJobsRequest) ScheduledByMain(scheduledByMain string) ApiSlurmdbV0040GetJobsRequest {
	r.scheduledByMain = &scheduledByMain
	return r
}

func (r ApiSlurmdbV0040GetJobsRequest) ScheduledByBackfill(scheduledByBackfill string) ApiSlurmdbV0040GetJobsRequest {
	r.scheduledByBackfill = &scheduledByBackfill
	return r
}

func (r ApiSlurmdbV0040GetJobsRequest) JobStarted(jobStarted string) ApiSlurmdbV0040GetJobsRequest {
	r.jobStarted = &jobStarted
	return r
}

// job exit code (numeric)
func (r ApiSlurmdbV0040GetJobsRequest) ExitCode(exitCode string) ApiSlurmdbV0040GetJobsRequest {
	r.exitCode = &exitCode
	return r
}

func (r ApiSlurmdbV0040GetJobsRequest) ShowDuplicates(showDuplicates string) ApiSlurmdbV0040GetJobsRequest {
	r.showDuplicates = &showDuplicates
	return r
}

func (r ApiSlurmdbV0040GetJobsRequest) SkipSteps(skipSteps string) ApiSlurmdbV0040GetJobsRequest {
	r.skipSteps = &skipSteps
	return r
}

func (r ApiSlurmdbV0040GetJobsRequest) DisableTruncateUsageTime(disableTruncateUsageTime string) ApiSlurmdbV0040GetJobsRequest {
	r.disableTruncateUsageTime = &disableTruncateUsageTime
	return r
}

func (r ApiSlurmdbV0040GetJobsRequest) WholeHetjob(wholeHetjob string) ApiSlurmdbV0040GetJobsRequest {
	r.wholeHetjob = &wholeHetjob
	return r
}

func (r ApiSlurmdbV0040GetJobsRequest) DisableWholeHetjob(disableWholeHetjob string) ApiSlurmdbV0040GetJobsRequest {
	r.disableWholeHetjob = &disableWholeHetjob
	return r
}

func (r ApiSlurmdbV0040GetJobsRequest) DisableWaitForResult(disableWaitForResult string) ApiSlurmdbV0040GetJobsRequest {
	r.disableWaitForResult = &disableWaitForResult
	return r
}

func (r ApiSlurmdbV0040GetJobsRequest) UsageTimeAsSubmitTime(usageTimeAsSubmitTime string) ApiSlurmdbV0040GetJobsRequest {
	r.usageTimeAsSubmitTime = &usageTimeAsSubmitTime
	return r
}

func (r ApiSlurmdbV0040GetJobsRequest) ShowBatchScript(showBatchScript string) ApiSlurmdbV0040GetJobsRequest {
	r.showBatchScript = &showBatchScript
	return r
}

func (r ApiSlurmdbV0040GetJobsRequest) ShowJobEnvironment(showJobEnvironment string) ApiSlurmdbV0040GetJobsRequest {
	r.showJobEnvironment = &showJobEnvironment
	return r
}

// CSV format list
func (r ApiSlurmdbV0040GetJobsRequest) Format(format string) ApiSlurmdbV0040GetJobsRequest {
	r.format = &format
	return r
}

// CSV group list
func (r ApiSlurmdbV0040GetJobsRequest) Groups(groups string) ApiSlurmdbV0040GetJobsRequest {
	r.groups = &groups
	return r
}

// CSV job name list
func (r ApiSlurmdbV0040GetJobsRequest) JobName(jobName string) ApiSlurmdbV0040GetJobsRequest {
	r.jobName = &jobName
	return r
}

// number of nodes high range
func (r ApiSlurmdbV0040GetJobsRequest) NodesMax(nodesMax string) ApiSlurmdbV0040GetJobsRequest {
	r.nodesMax = &nodesMax
	return r
}

// number of nodes low range
func (r ApiSlurmdbV0040GetJobsRequest) NodesMin(nodesMin string) ApiSlurmdbV0040GetJobsRequest {
	r.nodesMin = &nodesMin
	return r
}

// CSV partition name list
func (r ApiSlurmdbV0040GetJobsRequest) Partition(partition string) ApiSlurmdbV0040GetJobsRequest {
	r.partition = &partition
	return r
}

// CSV QOS name list
func (r ApiSlurmdbV0040GetJobsRequest) Qos(qos string) ApiSlurmdbV0040GetJobsRequest {
	r.qos = &qos
	return r
}

// CSV reason list
func (r ApiSlurmdbV0040GetJobsRequest) Reason(reason string) ApiSlurmdbV0040GetJobsRequest {
	r.reason = &reason
	return r
}

// CSV reservation name list
func (r ApiSlurmdbV0040GetJobsRequest) Reservation(reservation string) ApiSlurmdbV0040GetJobsRequest {
	r.reservation = &reservation
	return r
}

// CSV reservation ID list
func (r ApiSlurmdbV0040GetJobsRequest) ReservationId(reservationId string) ApiSlurmdbV0040GetJobsRequest {
	r.reservationId = &reservationId
	return r
}

// CSV state list
func (r ApiSlurmdbV0040GetJobsRequest) State(state string) ApiSlurmdbV0040GetJobsRequest {
	r.state = &state
	return r
}

// CSV step id list
func (r ApiSlurmdbV0040GetJobsRequest) Step(step string) ApiSlurmdbV0040GetJobsRequest {
	r.step = &step
	return r
}

// maximum timelimit (seconds)
func (r ApiSlurmdbV0040GetJobsRequest) TimelimitMax(timelimitMax string) ApiSlurmdbV0040GetJobsRequest {
	r.timelimitMax = &timelimitMax
	return r
}

// minimum timelimit (seconds)
func (r ApiSlurmdbV0040GetJobsRequest) TimelimitMin(timelimitMin string) ApiSlurmdbV0040GetJobsRequest {
	r.timelimitMin = &timelimitMin
	return r
}

// usage end timestamp
func (r ApiSlurmdbV0040GetJobsRequest) EndTime(endTime string) ApiSlurmdbV0040GetJobsRequest {
	r.endTime = &endTime
	return r
}

// usage start timestamp
func (r ApiSlurmdbV0040GetJobsRequest) StartTime(startTime string) ApiSlurmdbV0040GetJobsRequest {
	r.startTime = &startTime
	return r
}

// submit time timestamp
func (r ApiSlurmdbV0040GetJobsRequest) SubmitTime(submitTime string) ApiSlurmdbV0040GetJobsRequest {
	r.submitTime = &submitTime
	return r
}

// ranged node string where jobs ran
func (r ApiSlurmdbV0040GetJobsRequest) Node(node string) ApiSlurmdbV0040GetJobsRequest {
	r.node = &node
	return r
}

// CSV user name list
func (r ApiSlurmdbV0040GetJobsRequest) Users(users string) ApiSlurmdbV0040GetJobsRequest {
	r.users = &users
	return r
}

// CSV wckey list
func (r ApiSlurmdbV0040GetJobsRequest) Wckey(wckey string) ApiSlurmdbV0040GetJobsRequest {
	r.wckey = &wckey
	return r
}

func (r ApiSlurmdbV0040GetJobsRequest) Execute() (*V0040OpenapiSlurmdbdJobsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetJobsExecute(r)
}

/*
SlurmdbV0040GetJobs Get job list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040GetJobsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetJobs(ctx context.Context) ApiSlurmdbV0040GetJobsRequest {
	return ApiSlurmdbV0040GetJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiSlurmdbdJobsResp
func (a *SlurmdbAPIService) SlurmdbV0040GetJobsExecute(r ApiSlurmdbV0040GetJobsRequest) (*V0040OpenapiSlurmdbdJobsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiSlurmdbdJobsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/jobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.account != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account", r.account, "")
	}
	if r.association != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "association", r.association, "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "")
	}
	if r.constraints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "constraints", r.constraints, "")
	}
	if r.cpusMax != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cpus_max", r.cpusMax, "")
	}
	if r.cpusMin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cpus_min", r.cpusMin, "")
	}
	if r.schedulerUnset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduler_unset", r.schedulerUnset, "")
	}
	if r.scheduledOnSubmit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduled_on_submit", r.scheduledOnSubmit, "")
	}
	if r.scheduledByMain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduled_by_main", r.scheduledByMain, "")
	}
	if r.scheduledByBackfill != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduled_by_backfill", r.scheduledByBackfill, "")
	}
	if r.jobStarted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "job_started", r.jobStarted, "")
	}
	if r.exitCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exit_code", r.exitCode, "")
	}
	if r.showDuplicates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_duplicates", r.showDuplicates, "")
	}
	if r.skipSteps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip_steps", r.skipSteps, "")
	}
	if r.disableTruncateUsageTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "disable_truncate_usage_time", r.disableTruncateUsageTime, "")
	}
	if r.wholeHetjob != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "whole_hetjob", r.wholeHetjob, "")
	}
	if r.disableWholeHetjob != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "disable_whole_hetjob", r.disableWholeHetjob, "")
	}
	if r.disableWaitForResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "disable_wait_for_result", r.disableWaitForResult, "")
	}
	if r.usageTimeAsSubmitTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_time_as_submit_time", r.usageTimeAsSubmitTime, "")
	}
	if r.showBatchScript != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_batch_script", r.showBatchScript, "")
	}
	if r.showJobEnvironment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_job_environment", r.showJobEnvironment, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.groups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groups", r.groups, "")
	}
	if r.jobName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "job_name", r.jobName, "")
	}
	if r.nodesMax != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodes_max", r.nodesMax, "")
	}
	if r.nodesMin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodes_min", r.nodesMin, "")
	}
	if r.partition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partition", r.partition, "")
	}
	if r.qos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qos", r.qos, "")
	}
	if r.reason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reason", r.reason, "")
	}
	if r.reservation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservation", r.reservation, "")
	}
	if r.reservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservation_id", r.reservationId, "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "")
	}
	if r.step != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "step", r.step, "")
	}
	if r.timelimitMax != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timelimit_max", r.timelimitMax, "")
	}
	if r.timelimitMin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timelimit_min", r.timelimitMin, "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_time", r.endTime, "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_time", r.startTime, "")
	}
	if r.submitTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "submit_time", r.submitTime, "")
	}
	if r.node != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "node", r.node, "")
	}
	if r.users != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "users", r.users, "")
	}
	if r.wckey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wckey", r.wckey, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetQosRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	description *string
	id *string
	format *string
	name *string
	preemptMode *string
	withDeleted *string
}

// CSV description list
func (r ApiSlurmdbV0040GetQosRequest) Description(description string) ApiSlurmdbV0040GetQosRequest {
	r.description = &description
	return r
}

// CSV QOS id list
func (r ApiSlurmdbV0040GetQosRequest) Id(id string) ApiSlurmdbV0040GetQosRequest {
	r.id = &id
	return r
}

// CSV format list
func (r ApiSlurmdbV0040GetQosRequest) Format(format string) ApiSlurmdbV0040GetQosRequest {
	r.format = &format
	return r
}

// CSV QOS name list
func (r ApiSlurmdbV0040GetQosRequest) Name(name string) ApiSlurmdbV0040GetQosRequest {
	r.name = &name
	return r
}

func (r ApiSlurmdbV0040GetQosRequest) PreemptMode(preemptMode string) ApiSlurmdbV0040GetQosRequest {
	r.preemptMode = &preemptMode
	return r
}

// Include deleted QOS
func (r ApiSlurmdbV0040GetQosRequest) WithDeleted(withDeleted string) ApiSlurmdbV0040GetQosRequest {
	r.withDeleted = &withDeleted
	return r
}

func (r ApiSlurmdbV0040GetQosRequest) Execute() (*V0040OpenapiSlurmdbdQosResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetQosExecute(r)
}

/*
SlurmdbV0040GetQos Get QOS list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040GetQosRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetQos(ctx context.Context) ApiSlurmdbV0040GetQosRequest {
	return ApiSlurmdbV0040GetQosRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiSlurmdbdQosResp
func (a *SlurmdbAPIService) SlurmdbV0040GetQosExecute(r ApiSlurmdbV0040GetQosRequest) (*V0040OpenapiSlurmdbdQosResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiSlurmdbdQosResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetQos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/qos"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.preemptMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preempt_mode", r.preemptMode, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiSlurmdbdQosResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetSingleQosRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	qos string
	withDeleted *string
}

// Query includes deleted QOS
func (r ApiSlurmdbV0040GetSingleQosRequest) WithDeleted(withDeleted string) ApiSlurmdbV0040GetSingleQosRequest {
	r.withDeleted = &withDeleted
	return r
}

func (r ApiSlurmdbV0040GetSingleQosRequest) Execute() (*V0040OpenapiSlurmdbdQosResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetSingleQosExecute(r)
}

/*
SlurmdbV0040GetSingleQos Get QOS info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param qos QOS name
 @return ApiSlurmdbV0040GetSingleQosRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetSingleQos(ctx context.Context, qos string) ApiSlurmdbV0040GetSingleQosRequest {
	return ApiSlurmdbV0040GetSingleQosRequest{
		ApiService: a,
		ctx: ctx,
		qos: qos,
	}
}

// Execute executes the request
//  @return V0040OpenapiSlurmdbdQosResp
func (a *SlurmdbAPIService) SlurmdbV0040GetSingleQosExecute(r ApiSlurmdbV0040GetSingleQosRequest) (*V0040OpenapiSlurmdbdQosResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiSlurmdbdQosResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetSingleQos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/qos/{qos}"
	localVarPath = strings.Replace(localVarPath, "{"+"qos"+"}", url.PathEscape(parameterValueToString(r.qos, "qos")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiSlurmdbdQosResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetTresRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
}

func (r ApiSlurmdbV0040GetTresRequest) Execute() (*V0040OpenapiTresResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetTresExecute(r)
}

/*
SlurmdbV0040GetTres Get TRES info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040GetTresRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetTres(ctx context.Context) ApiSlurmdbV0040GetTresRequest {
	return ApiSlurmdbV0040GetTresRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiTresResp
func (a *SlurmdbAPIService) SlurmdbV0040GetTresExecute(r ApiSlurmdbV0040GetTresRequest) (*V0040OpenapiTresResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiTresResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetTres")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/tres"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetUserRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	name string
	withDeleted *string
	withAssocs *string
	withCoords *string
	withWckeys *string
}

// Include deleted users
func (r ApiSlurmdbV0040GetUserRequest) WithDeleted(withDeleted string) ApiSlurmdbV0040GetUserRequest {
	r.withDeleted = &withDeleted
	return r
}

// Include assocations
func (r ApiSlurmdbV0040GetUserRequest) WithAssocs(withAssocs string) ApiSlurmdbV0040GetUserRequest {
	r.withAssocs = &withAssocs
	return r
}

// Include coordinators
func (r ApiSlurmdbV0040GetUserRequest) WithCoords(withCoords string) ApiSlurmdbV0040GetUserRequest {
	r.withCoords = &withCoords
	return r
}

// Include wckeys
func (r ApiSlurmdbV0040GetUserRequest) WithWckeys(withWckeys string) ApiSlurmdbV0040GetUserRequest {
	r.withWckeys = &withWckeys
	return r
}

func (r ApiSlurmdbV0040GetUserRequest) Execute() (*V0040OpenapiUsersResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetUserExecute(r)
}

/*
SlurmdbV0040GetUser Get user info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name User name
 @return ApiSlurmdbV0040GetUserRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetUser(ctx context.Context, name string) ApiSlurmdbV0040GetUserRequest {
	return ApiSlurmdbV0040GetUserRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V0040OpenapiUsersResp
func (a *SlurmdbAPIService) SlurmdbV0040GetUserExecute(r ApiSlurmdbV0040GetUserRequest) (*V0040OpenapiUsersResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiUsersResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/user/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	if r.withAssocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_assocs", r.withAssocs, "")
	}
	if r.withCoords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_coords", r.withCoords, "")
	}
	if r.withWckeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_wckeys", r.withWckeys, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetUsersRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	adminLevel *string
	defaultAccount *string
	defaultWckey *string
	withAssocs *string
	withCoords *string
	withDeleted *string
	withWckeys *string
	withoutDefaults *string
}

// Administrator level
func (r ApiSlurmdbV0040GetUsersRequest) AdminLevel(adminLevel string) ApiSlurmdbV0040GetUsersRequest {
	r.adminLevel = &adminLevel
	return r
}

// CSV default account list
func (r ApiSlurmdbV0040GetUsersRequest) DefaultAccount(defaultAccount string) ApiSlurmdbV0040GetUsersRequest {
	r.defaultAccount = &defaultAccount
	return r
}

// CSV default wckey list
func (r ApiSlurmdbV0040GetUsersRequest) DefaultWckey(defaultWckey string) ApiSlurmdbV0040GetUsersRequest {
	r.defaultWckey = &defaultWckey
	return r
}

// With associations
func (r ApiSlurmdbV0040GetUsersRequest) WithAssocs(withAssocs string) ApiSlurmdbV0040GetUsersRequest {
	r.withAssocs = &withAssocs
	return r
}

// With coordinators
func (r ApiSlurmdbV0040GetUsersRequest) WithCoords(withCoords string) ApiSlurmdbV0040GetUsersRequest {
	r.withCoords = &withCoords
	return r
}

// With deleted
func (r ApiSlurmdbV0040GetUsersRequest) WithDeleted(withDeleted string) ApiSlurmdbV0040GetUsersRequest {
	r.withDeleted = &withDeleted
	return r
}

// With wckeys
func (r ApiSlurmdbV0040GetUsersRequest) WithWckeys(withWckeys string) ApiSlurmdbV0040GetUsersRequest {
	r.withWckeys = &withWckeys
	return r
}

// Exclude defaults
func (r ApiSlurmdbV0040GetUsersRequest) WithoutDefaults(withoutDefaults string) ApiSlurmdbV0040GetUsersRequest {
	r.withoutDefaults = &withoutDefaults
	return r
}

func (r ApiSlurmdbV0040GetUsersRequest) Execute() (*V0040OpenapiUsersResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetUsersExecute(r)
}

/*
SlurmdbV0040GetUsers Get user list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040GetUsersRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetUsers(ctx context.Context) ApiSlurmdbV0040GetUsersRequest {
	return ApiSlurmdbV0040GetUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiUsersResp
func (a *SlurmdbAPIService) SlurmdbV0040GetUsersExecute(r ApiSlurmdbV0040GetUsersRequest) (*V0040OpenapiUsersResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiUsersResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.adminLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "admin_level", r.adminLevel, "")
	}
	if r.defaultAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_account", r.defaultAccount, "")
	}
	if r.defaultWckey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_wckey", r.defaultWckey, "")
	}
	if r.withAssocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_assocs", r.withAssocs, "")
	}
	if r.withCoords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_coords", r.withCoords, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	if r.withWckeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_wckeys", r.withWckeys, "")
	}
	if r.withoutDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_defaults", r.withoutDefaults, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetWckeyRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	id string
}

func (r ApiSlurmdbV0040GetWckeyRequest) Execute() (*V0040OpenapiWckeyResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetWckeyExecute(r)
}

/*
SlurmdbV0040GetWckey Get wckey info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id wckey id
 @return ApiSlurmdbV0040GetWckeyRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetWckey(ctx context.Context, id string) ApiSlurmdbV0040GetWckeyRequest {
	return ApiSlurmdbV0040GetWckeyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V0040OpenapiWckeyResp
func (a *SlurmdbAPIService) SlurmdbV0040GetWckeyExecute(r ApiSlurmdbV0040GetWckeyRequest) (*V0040OpenapiWckeyResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiWckeyResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetWckey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/wckey/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040GetWckeysRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	cluster *string
	format *string
	id *string
	name *string
	onlyDefaults *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
}

// CSV cluster name list
func (r ApiSlurmdbV0040GetWckeysRequest) Cluster(cluster string) ApiSlurmdbV0040GetWckeysRequest {
	r.cluster = &cluster
	return r
}

// CSV format name list
func (r ApiSlurmdbV0040GetWckeysRequest) Format(format string) ApiSlurmdbV0040GetWckeysRequest {
	r.format = &format
	return r
}

// CSV id list
func (r ApiSlurmdbV0040GetWckeysRequest) Id(id string) ApiSlurmdbV0040GetWckeysRequest {
	r.id = &id
	return r
}

// CSV name list
func (r ApiSlurmdbV0040GetWckeysRequest) Name(name string) ApiSlurmdbV0040GetWckeysRequest {
	r.name = &name
	return r
}

// only query defaults
func (r ApiSlurmdbV0040GetWckeysRequest) OnlyDefaults(onlyDefaults string) ApiSlurmdbV0040GetWckeysRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// usage end UNIX timestamp (seconds)
func (r ApiSlurmdbV0040GetWckeysRequest) UsageEnd(usageEnd string) ApiSlurmdbV0040GetWckeysRequest {
	r.usageEnd = &usageEnd
	return r
}

// usage start UNIX timestamp (seconds)
func (r ApiSlurmdbV0040GetWckeysRequest) UsageStart(usageStart string) ApiSlurmdbV0040GetWckeysRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r ApiSlurmdbV0040GetWckeysRequest) User(user string) ApiSlurmdbV0040GetWckeysRequest {
	r.user = &user
	return r
}

// include usage with query
func (r ApiSlurmdbV0040GetWckeysRequest) WithUsage(withUsage string) ApiSlurmdbV0040GetWckeysRequest {
	r.withUsage = &withUsage
	return r
}

// include deleted wckeys with query
func (r ApiSlurmdbV0040GetWckeysRequest) WithDeleted(withDeleted string) ApiSlurmdbV0040GetWckeysRequest {
	r.withDeleted = &withDeleted
	return r
}

func (r ApiSlurmdbV0040GetWckeysRequest) Execute() (*V0040OpenapiWckeyResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetWckeysExecute(r)
}

/*
SlurmdbV0040GetWckeys Get wckey list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040GetWckeysRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetWckeys(ctx context.Context) ApiSlurmdbV0040GetWckeysRequest {
	return ApiSlurmdbV0040GetWckeysRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiWckeyResp
func (a *SlurmdbAPIService) SlurmdbV0040GetWckeysExecute(r ApiSlurmdbV0040GetWckeysRequest) (*V0040OpenapiWckeyResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiWckeyResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetWckeys")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/wckeys"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040PostAccountsRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	v0040OpenapiAccountsResp *V0040OpenapiAccountsResp
}

// update/create accounts
func (r ApiSlurmdbV0040PostAccountsRequest) V0040OpenapiAccountsResp(v0040OpenapiAccountsResp V0040OpenapiAccountsResp) ApiSlurmdbV0040PostAccountsRequest {
	r.v0040OpenapiAccountsResp = &v0040OpenapiAccountsResp
	return r
}

func (r ApiSlurmdbV0040PostAccountsRequest) Execute() (*V0040OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040PostAccountsExecute(r)
}

/*
SlurmdbV0040PostAccounts Update accounts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040PostAccountsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040PostAccounts(ctx context.Context) ApiSlurmdbV0040PostAccountsRequest {
	return ApiSlurmdbV0040PostAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0040PostAccountsExecute(r ApiSlurmdbV0040PostAccountsRequest) (*V0040OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040PostAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v0040OpenapiAccountsResp == nil {
		return localVarReturnValue, nil, reportError("v0040OpenapiAccountsResp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0040OpenapiAccountsResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040PostAccountsAssociationRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	v0040OpenapiAccountsAddCondResp *V0040OpenapiAccountsAddCondResp
}

// Create accounts with conditional association
func (r ApiSlurmdbV0040PostAccountsAssociationRequest) V0040OpenapiAccountsAddCondResp(v0040OpenapiAccountsAddCondResp V0040OpenapiAccountsAddCondResp) ApiSlurmdbV0040PostAccountsAssociationRequest {
	r.v0040OpenapiAccountsAddCondResp = &v0040OpenapiAccountsAddCondResp
	return r
}

func (r ApiSlurmdbV0040PostAccountsAssociationRequest) Execute() (*V0040OpenapiAccountsAddCondRespStr, *http.Response, error) {
	return r.ApiService.SlurmdbV0040PostAccountsAssociationExecute(r)
}

/*
SlurmdbV0040PostAccountsAssociation Add accounts with conditional association

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040PostAccountsAssociationRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040PostAccountsAssociation(ctx context.Context) ApiSlurmdbV0040PostAccountsAssociationRequest {
	return ApiSlurmdbV0040PostAccountsAssociationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiAccountsAddCondRespStr
func (a *SlurmdbAPIService) SlurmdbV0040PostAccountsAssociationExecute(r ApiSlurmdbV0040PostAccountsAssociationRequest) (*V0040OpenapiAccountsAddCondRespStr, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiAccountsAddCondRespStr
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040PostAccountsAssociation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/accounts_association"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v0040OpenapiAccountsAddCondResp == nil {
		return localVarReturnValue, nil, reportError("v0040OpenapiAccountsAddCondResp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0040OpenapiAccountsAddCondResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiAccountsAddCondRespStr
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040PostAssociationsRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	v0040OpenapiAssocsResp *V0040OpenapiAssocsResp
}

// Add or update associations
func (r ApiSlurmdbV0040PostAssociationsRequest) V0040OpenapiAssocsResp(v0040OpenapiAssocsResp V0040OpenapiAssocsResp) ApiSlurmdbV0040PostAssociationsRequest {
	r.v0040OpenapiAssocsResp = &v0040OpenapiAssocsResp
	return r
}

func (r ApiSlurmdbV0040PostAssociationsRequest) Execute() (*V0040OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040PostAssociationsExecute(r)
}

/*
SlurmdbV0040PostAssociations Set associations info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040PostAssociationsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040PostAssociations(ctx context.Context) ApiSlurmdbV0040PostAssociationsRequest {
	return ApiSlurmdbV0040PostAssociationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0040PostAssociationsExecute(r ApiSlurmdbV0040PostAssociationsRequest) (*V0040OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040PostAssociations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/associations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v0040OpenapiAssocsResp == nil {
		return localVarReturnValue, nil, reportError("v0040OpenapiAssocsResp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0040OpenapiAssocsResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040PostClustersRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	v0040OpenapiClustersResp *V0040OpenapiClustersResp
}

// Add or modify clusters
func (r ApiSlurmdbV0040PostClustersRequest) V0040OpenapiClustersResp(v0040OpenapiClustersResp V0040OpenapiClustersResp) ApiSlurmdbV0040PostClustersRequest {
	r.v0040OpenapiClustersResp = &v0040OpenapiClustersResp
	return r
}

func (r ApiSlurmdbV0040PostClustersRequest) Execute() (*V0040OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040PostClustersExecute(r)
}

/*
SlurmdbV0040PostClusters update clusters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040PostClustersRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040PostClusters(ctx context.Context) ApiSlurmdbV0040PostClustersRequest {
	return ApiSlurmdbV0040PostClustersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0040PostClustersExecute(r ApiSlurmdbV0040PostClustersRequest) (*V0040OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040PostClusters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/clusters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v0040OpenapiClustersResp == nil {
		return localVarReturnValue, nil, reportError("v0040OpenapiClustersResp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0040OpenapiClustersResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040PostConfigRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	v0040OpenapiSlurmdbdConfigResp *V0040OpenapiSlurmdbdConfigResp
}

// Add or update config
func (r ApiSlurmdbV0040PostConfigRequest) V0040OpenapiSlurmdbdConfigResp(v0040OpenapiSlurmdbdConfigResp V0040OpenapiSlurmdbdConfigResp) ApiSlurmdbV0040PostConfigRequest {
	r.v0040OpenapiSlurmdbdConfigResp = &v0040OpenapiSlurmdbdConfigResp
	return r
}

func (r ApiSlurmdbV0040PostConfigRequest) Execute() (*V0040OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040PostConfigExecute(r)
}

/*
SlurmdbV0040PostConfig Load all configuration information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040PostConfigRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040PostConfig(ctx context.Context) ApiSlurmdbV0040PostConfigRequest {
	return ApiSlurmdbV0040PostConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0040PostConfigExecute(r ApiSlurmdbV0040PostConfigRequest) (*V0040OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040PostConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0040OpenapiSlurmdbdConfigResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040PostQosRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	v0040OpenapiSlurmdbdQosResp *V0040OpenapiSlurmdbdQosResp
}

// Add or update QOSs
func (r ApiSlurmdbV0040PostQosRequest) V0040OpenapiSlurmdbdQosResp(v0040OpenapiSlurmdbdQosResp V0040OpenapiSlurmdbdQosResp) ApiSlurmdbV0040PostQosRequest {
	r.v0040OpenapiSlurmdbdQosResp = &v0040OpenapiSlurmdbdQosResp
	return r
}

func (r ApiSlurmdbV0040PostQosRequest) Execute() (*V0040OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040PostQosExecute(r)
}

/*
SlurmdbV0040PostQos Set QOS info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040PostQosRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040PostQos(ctx context.Context) ApiSlurmdbV0040PostQosRequest {
	return ApiSlurmdbV0040PostQosRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0040PostQosExecute(r ApiSlurmdbV0040PostQosRequest) (*V0040OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040PostQos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/qos"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v0040OpenapiSlurmdbdQosResp == nil {
		return localVarReturnValue, nil, reportError("v0040OpenapiSlurmdbdQosResp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0040OpenapiSlurmdbdQosResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040PostTresRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	v0040OpenapiTresResp *V0040OpenapiTresResp
}

// Add or Update TRES
func (r ApiSlurmdbV0040PostTresRequest) V0040OpenapiTresResp(v0040OpenapiTresResp V0040OpenapiTresResp) ApiSlurmdbV0040PostTresRequest {
	r.v0040OpenapiTresResp = &v0040OpenapiTresResp
	return r
}

func (r ApiSlurmdbV0040PostTresRequest) Execute() (*V0040OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040PostTresExecute(r)
}

/*
SlurmdbV0040PostTres Set TRES info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040PostTresRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040PostTres(ctx context.Context) ApiSlurmdbV0040PostTresRequest {
	return ApiSlurmdbV0040PostTresRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0040PostTresExecute(r ApiSlurmdbV0040PostTresRequest) (*V0040OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040PostTres")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/tres"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v0040OpenapiTresResp == nil {
		return localVarReturnValue, nil, reportError("v0040OpenapiTresResp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0040OpenapiTresResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040PostUsersRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	v0040OpenapiUsersResp *V0040OpenapiUsersResp
}

// add or update user
func (r ApiSlurmdbV0040PostUsersRequest) V0040OpenapiUsersResp(v0040OpenapiUsersResp V0040OpenapiUsersResp) ApiSlurmdbV0040PostUsersRequest {
	r.v0040OpenapiUsersResp = &v0040OpenapiUsersResp
	return r
}

func (r ApiSlurmdbV0040PostUsersRequest) Execute() (*V0040OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040PostUsersExecute(r)
}

/*
SlurmdbV0040PostUsers Update user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040PostUsersRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040PostUsers(ctx context.Context) ApiSlurmdbV0040PostUsersRequest {
	return ApiSlurmdbV0040PostUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0040PostUsersExecute(r ApiSlurmdbV0040PostUsersRequest) (*V0040OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040PostUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v0040OpenapiUsersResp == nil {
		return localVarReturnValue, nil, reportError("v0040OpenapiUsersResp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0040OpenapiUsersResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040PostUsersAssociationRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	v0040OpenapiUsersAddCondResp *V0040OpenapiUsersAddCondResp
}

// Create users with conditional association
func (r ApiSlurmdbV0040PostUsersAssociationRequest) V0040OpenapiUsersAddCondResp(v0040OpenapiUsersAddCondResp V0040OpenapiUsersAddCondResp) ApiSlurmdbV0040PostUsersAssociationRequest {
	r.v0040OpenapiUsersAddCondResp = &v0040OpenapiUsersAddCondResp
	return r
}

func (r ApiSlurmdbV0040PostUsersAssociationRequest) Execute() (*V0040OpenapiUsersAddCondRespStr, *http.Response, error) {
	return r.ApiService.SlurmdbV0040PostUsersAssociationExecute(r)
}

/*
SlurmdbV0040PostUsersAssociation Add users with conditional association

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040PostUsersAssociationRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040PostUsersAssociation(ctx context.Context) ApiSlurmdbV0040PostUsersAssociationRequest {
	return ApiSlurmdbV0040PostUsersAssociationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiUsersAddCondRespStr
func (a *SlurmdbAPIService) SlurmdbV0040PostUsersAssociationExecute(r ApiSlurmdbV0040PostUsersAssociationRequest) (*V0040OpenapiUsersAddCondRespStr, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiUsersAddCondRespStr
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040PostUsersAssociation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/users_association"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v0040OpenapiUsersAddCondResp == nil {
		return localVarReturnValue, nil, reportError("v0040OpenapiUsersAddCondResp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0040OpenapiUsersAddCondResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiUsersAddCondRespStr
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlurmdbV0040PostWckeysRequest struct {
	ctx context.Context
	ApiService *SlurmdbAPIService
	v0040OpenapiWckeyResp *V0040OpenapiWckeyResp
}

// add wckeys
func (r ApiSlurmdbV0040PostWckeysRequest) V0040OpenapiWckeyResp(v0040OpenapiWckeyResp V0040OpenapiWckeyResp) ApiSlurmdbV0040PostWckeysRequest {
	r.v0040OpenapiWckeyResp = &v0040OpenapiWckeyResp
	return r
}

func (r ApiSlurmdbV0040PostWckeysRequest) Execute() (*V0040OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040PostWckeysExecute(r)
}

/*
SlurmdbV0040PostWckeys Add wckeys

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlurmdbV0040PostWckeysRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040PostWckeys(ctx context.Context) ApiSlurmdbV0040PostWckeysRequest {
	return ApiSlurmdbV0040PostWckeysRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0040PostWckeysExecute(r ApiSlurmdbV0040PostWckeysRequest) (*V0040OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040PostWckeys")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/wckeys"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0040OpenapiWckeyResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
